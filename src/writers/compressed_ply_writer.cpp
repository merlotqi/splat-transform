/**
 * splat - A C++ library for reading and writing 3D Gaussian Splatting (splat) files.
 *
 * This library provides functionality to convert, manipulate, and process
 * 3D Gaussian splatting data formats used in real-time neural rendering.
 *
 * This file is part of splat.
 *
 * splat is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * splat is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 *
 * For more information, visit the project's homepage or contact the author.
 */

#include <absl/strings/str_join.h>
#include <splat/splat_version.h>
#include <splat/writers/compressed_chunk.h>
#include <splat/writers/compressed_ply_writer.h>


namespace splat {

#define SPLAT_GENERATED_BY_STRING "Generated by splat-transform " SPLAT_VERSION

constexpr const char* generatedByString() { return SPLAT_GENERATED_BY_STRING; }

// clang-format off

static std::array<std::string, 18> chunkProps = {
    "min_x", "min_y", "min_z",
    "max_x", "max_y", "max_z",
    "min_scale_x", "min_scale_y", "min_scale_z",
    "max_scale_x", "max_scale_y", "max_scale_z",
    "min_r", "min_g", "min_b",
    "max_r", "max_g", "max_b"
};

static std::array<std::string, 4> vertexProps = {
    "packed_position",
    "packed_rotation",
    "packed_scale",
    "packed_color"
};

static std::array<std::string, 45> shNames = {"f_rest_0",  "f_rest_1",  "f_rest_2",  "f_rest_3",  "f_rest_4",
                                              "f_rest_5",  "f_rest_6",  "f_rest_7",  "f_rest_8",

                                              "f_rest_9",  "f_rest_10", "f_rest_11", "f_rest_12", "f_rest_13",
                                              "f_rest_14", "f_rest_15", "f_rest_16", "f_rest_17",

                                              "f_rest_18", "f_rest_19", "f_rest_20", "f_rest_21", "f_rest_22",
                                              "f_rest_23", "f_rest_24", "f_rest_25", "f_rest_26",

                                              "f_rest_27", "f_rest_28", "f_rest_29", "f_rest_30", "f_rest_31",
                                              "f_rest_32", "f_rest_33", "f_rest_34", "f_rest_35",

                                              "f_rest_36", "f_rest_37", "f_rest_38", "f_rest_39", "f_rest_40",
                                              "f_rest_41", "f_rest_42", "f_rest_43", "f_rest_44"};

// clang-format on

static constexpr auto CHUNK_SIZE = 256ULL;

void writeCompressedPly(const std::string& filename, DataTable dataTable) {
  auto it =
      std::find_if(shNames.begin(), shNames.end(), [&](const std::string& name) { return !dataTable.hasColumn(name); });

  int missingIdx = (it == shNames.end()) ? -1 : std::distance(shNames.begin(), it);
  int shBands = 0;
  switch (missingIdx) {
    case 9:
      shBands = 1;
      break;
    case 24:
      shBands = 2;
      break;
    case -1:
      shBands = 3;
      break;
    default:
      shBands = 0;
      break;
  };
  const int outputSHCoeffs = (shBands == 0) ? 0 : (shBands * shBands + 2 * shBands);

  const size_t numSplats = dataTable.getNumRows();
  const size_t numChunks = ceil(numSplats / CHUNK_SIZE);

  std::string shHeader = {};

  if (shBands > 0) {
    shHeader += "element sh " + std::to_string(numSplats) + "\n";
    for (int i = 0; i < outputSHCoeffs * 3; ++i) {
      shHeader += "property uchar f_rest_" + std::to_string(i) + "\n";
    }
  }

  std::vector<std::string> headerTexts;
  headerTexts.emplace_back("ply");
  headerTexts.emplace_back("format binary_little_endian 1.0");
  headerTexts.emplace_back("comment " + std::string(generatedByString()));
  for (auto& p : chunkProps) {
    headerTexts.emplace_back("property float " + p);
  }
  headerTexts.emplace_back("element vertex " + std::to_string(numChunks));
  for (auto& p : vertexProps) {
    headerTexts.emplace_back("property uint " + p);
  }
  headerTexts.emplace_back(shHeader);
  headerTexts.emplace_back("end_header");

  std::string headerText = absl::StrJoin(headerTexts, "\n");
  std::vector<float> chunkData(numChunks * chunkProps.size(), 0.0f);
  std::vector<uint32_t> splatIData(numChunks * vertexProps.size(), 0);
  std::vector<uint8_t> shData(numSplats * outputSHCoeffs * 3, 0);
  // sort splats into some kind of order (morton order rn)
  std::vector<uint32_t> sortIndices(dataTable.getNumRows(), 0);
  for (size_t i = 0; i < sortIndices.size(); ++i) {
    sortIndices[i] = i;
  }
  generateOrdering(dataTable, sortIndices);

  Row row;
  CompressedChunk chunk;
  for (size_t i = 0; i < numChunks; i++) {
    const int num = std::min(numSplats, (i + 1) * CHUNK_SIZE) - i * CHUNK_SIZE;
    for (size_t j = 0; j < num; j++) {
      const uint32_t index = sortIndices[i * CHUNK_SIZE + j];

      // read splat data
      dataTable.getRow(index, row);

      // quantize and write sh data
      chunk.set(j, row);

      // quantize and write sh data
      auto off = (i * CHUNK_SIZE + j) * outputSHCoeffs * 3;
      for (size_t k = 0; k < outputSHCoeffs * 3; k++) {
        const auto nvalue = row[shNames[k]] / 8 + 0.5f;
        shData[off++] = std::max(0, std::min(255, (int)trunc(nvalue * 256)));
      }
    }

    // repeat the last gaussian to fill the rest of the final chunk
    for (size_t j = 0; j < CHUNK_SIZE; j++) {
      chunk.set(j, row);
    }

    // pack the chunk
    chunk.pack();
  }
}

#undef SPLAT_GENERATED_BY_STRING

}  // namespace splat
