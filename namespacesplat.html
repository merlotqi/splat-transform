<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SplatLib: splat Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SplatLib
   &#160;<span id="projectnumber">1.3.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">splat Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacesplat_1_1webpcodec"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesplat_1_1webpcodec.html">webpcodec</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsplat_1_1CompressedChunk.html">CompressedChunk</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsplat_1_1RotateSH.html">RotateSH</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotation matrices for spherical harmonics up to band 3.  <a href="structsplat_1_1RotateSH.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsplat_1_1Column.html">Column</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a single column of typed data with metadata.  <a href="structsplat_1_1Column.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsplat_1_1DataTable.html">DataTable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tabular data structure with typed columns.  <a href="classsplat_1_1DataTable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsplat_1_1LccLod.html">LccLod</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsplat_1_1LccUnitInfo.html">LccUnitInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsplat_1_1CompressInfo.html">CompressInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsplat_1_1LccParam.html">LccParam</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsplat_1_1ProcessUnitContext.html">ProcessUnitContext</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsplat_1_1PlyProperty.html">PlyProperty</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a single property definition in a PLY element.  <a href="structsplat_1_1PlyProperty.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsplat_1_1PlyElement.html">PlyElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a PLY element (group of properties) in the header.  <a href="structsplat_1_1PlyElement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsplat_1_1PlyHeader.html">PlyHeader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complete PLY file header information.  <a href="structsplat_1_1PlyHeader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsplat_1_1PlyElementData.html">PlyElementData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains actual data for a PLY element along with its name.  <a href="structsplat_1_1PlyElementData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsplat_1_1PlyData.html">PlyData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complete in-memory representation of PLY file data.  <a href="structsplat_1_1PlyData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsplat_1_1Meta.html">Meta</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metadata structure for Gaussian Splatting data representation.  <a href="structsplat_1_1Meta.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsplat_1_1VoxelMetadata.html">VoxelMetadata</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsplat_1_1ColumnStats.html">ColumnStats</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statistical summary for a single data column.  <a href="structsplat_1_1ColumnStats.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsplat_1_1SummaryData.html">SummaryData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statistical summary for an entire <a class="el" href="classsplat_1_1DataTable.html" title="Tabular data structure with typed columns.">DataTable</a>.  <a href="structsplat_1_1SummaryData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsplat_1_1BTree.html">BTree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bounding Volume Hierarchy (BVH) tree implementation using Axis-Aligned Bounding Boxes (AABBs).  <a href="classsplat_1_1BTree.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsplat_1_1GaussianExtentsResult.html">GaussianExtentsResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsplat_1_1GaussianBVH.html">GaussianBVH</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsplat_1_1KdTree.html">KdTree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">K-dimensional tree for efficient spatial queries on 3D Gaussian splatting data.  <a href="classsplat_1_1KdTree.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsplat_1_1Bounds.html">Bounds</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsplat_1_1BlockAccumulator.html">BlockAccumulator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsplat_1_1SparseOctree.html">SparseOctree</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsplat_1_1Crc.html">Crc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsplat_1_1Logger.html">Logger</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsplat_1_1ZipEntry.html">ZipEntry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsplat_1_1ZipReader.html">ZipReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimal ZIP reader supporting STORED (method 0) and data descriptors. It sequentially parses Local File Headers to list entries.  <a href="classsplat_1_1ZipReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsplat_1_1FileInfo.html">FileInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the metadata for a single file entry within the archive.  <a href="structsplat_1_1FileInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsplat_1_1ZipWriter.html">ZipWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous streaming ZIP archive writer.  <a href="classsplat_1_1ZipWriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a034ac2e2d75dce80bc73c9188bff5e18"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesplat.html#a034ac2e2d75dce80bc73c9188bff5e18">Row</a> = std::map&lt; std::string, float &gt;</td></tr>
<tr class="memdesc:a034ac2e2d75dce80bc73c9188bff5e18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a single row of data as a map of column names to float values.  <a href="namespacesplat.html#a034ac2e2d75dce80bc73c9188bff5e18">More...</a><br /></td></tr>
<tr class="separator:a034ac2e2d75dce80bc73c9188bff5e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15efefd4b08a86eb5541d30becb14627"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesplat.html#a15efefd4b08a86eb5541d30becb14627">TypedArray</a> = std::variant&lt; std::vector&lt; int8_t &gt;, std::vector&lt; uint8_t &gt;, std::vector&lt; int16_t &gt;, std::vector&lt; uint16_t &gt;, std::vector&lt; int32_t &gt;, std::vector&lt; uint32_t &gt;, std::vector&lt; float &gt;, std::vector&lt; double &gt; &gt;</td></tr>
<tr class="memdesc:a15efefd4b08a86eb5541d30becb14627"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant type representing different typed array storage options.  <a href="namespacesplat.html#a15efefd4b08a86eb5541d30becb14627">More...</a><br /></td></tr>
<tr class="separator:a15efefd4b08a86eb5541d30becb14627"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a382cd5d5a35ce21b5ae92ab9821c849c"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesplat.html#a382cd5d5a35ce21b5ae92ab9821c849c">ColumnType</a> : uint8_t { <br />
&#160;&#160;<a class="el" href="namespacesplat.html#a382cd5d5a35ce21b5ae92ab9821c849caee9d73311ff0658494edfff14c3ec1e3">INT8</a>
, <a class="el" href="namespacesplat.html#a382cd5d5a35ce21b5ae92ab9821c849caecfc091ed2a607335524c8389cfa41b5">UINT8</a>
, <a class="el" href="namespacesplat.html#a382cd5d5a35ce21b5ae92ab9821c849ca5f90af42814c0a419d715d43ae54fd7a">INT16</a>
, <a class="el" href="namespacesplat.html#a382cd5d5a35ce21b5ae92ab9821c849ca48d8f1a723d44ff4a87db1bb6c551c62">UINT16</a>
, <br />
&#160;&#160;<a class="el" href="namespacesplat.html#a382cd5d5a35ce21b5ae92ab9821c849ca6495adba09844fac8eeb0aba86e6f1bf">INT32</a>
, <a class="el" href="namespacesplat.html#a382cd5d5a35ce21b5ae92ab9821c849ca17266551181f69a1b4a3ad5c9e270afc">UINT32</a>
, <a class="el" href="namespacesplat.html#a382cd5d5a35ce21b5ae92ab9821c849ca967d280b5c16d95f2947647dd2ca6cc2">FLOAT32</a>
, <a class="el" href="namespacesplat.html#a382cd5d5a35ce21b5ae92ab9821c849ca139882c654db8a57f7c3092de1dd0b02">FLOAT64</a>
<br />
 }</td></tr>
<tr class="memdesc:a382cd5d5a35ce21b5ae92ab9821c849c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of supported column data types.  <a href="namespacesplat.html#a382cd5d5a35ce21b5ae92ab9821c849c">More...</a><br /></td></tr>
<tr class="separator:a382cd5d5a35ce21b5ae92ab9821c849c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e7c2f7ae07b287f4c45ed56d387579"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesplat.html#a06e7c2f7ae07b287f4c45ed56d387579">logLevel</a> { <a class="el" href="namespacesplat.html#a06e7c2f7ae07b287f4c45ed56d387579a73be252ca82217b1458a25e6b4e99f15">silent</a>
, <a class="el" href="namespacesplat.html#a06e7c2f7ae07b287f4c45ed56d387579afea087517c26fadd409bd4b9dc642555">normal</a>
 }</td></tr>
<tr class="separator:a06e7c2f7ae07b287f4c45ed56d387579"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aca057d27b7f853b0e501bfffb6f7e971"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesplat.html#aca057d27b7f853b0e501bfffb6f7e971">writeCompressedPly</a> (const std::string &amp;filename, <a class="el" href="classsplat_1_1DataTable.html">DataTable</a> *dataTable)</td></tr>
<tr class="separator:aca057d27b7f853b0e501bfffb6f7e971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bfa1469594d0e1f3077bcf114fa2b11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesplat.html#a0bfa1469594d0e1f3077bcf114fa2b11">writeCSV</a> (const std::string &amp;path, <a class="el" href="classsplat_1_1DataTable.html">DataTable</a> *dataTable)</td></tr>
<tr class="separator:a0bfa1469594d0e1f3077bcf114fa2b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07152f181a31a582c288178ffc5f9546"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesplat.html#a07152f181a31a582c288178ffc5f9546">isCompressedPly</a> (const <a class="el" href="structsplat_1_1PlyData.html">PlyData</a> *ply)</td></tr>
<tr class="separator:a07152f181a31a582c288178ffc5f9546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa252f193c70195f18e271769fa16e2ad"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classsplat_1_1DataTable.html">DataTable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesplat.html#aa252f193c70195f18e271769fa16e2ad">decompressPly</a> (const <a class="el" href="structsplat_1_1PlyData.html">PlyData</a> *ply)</td></tr>
<tr class="separator:aa252f193c70195f18e271769fa16e2ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8111464ced8f5fc3d201a2a0c8f4ca5b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classsplat_1_1DataTable.html">DataTable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesplat.html#a8111464ced8f5fc3d201a2a0c8f4ca5b">readKsplat</a> (const std::string &amp;filename)</td></tr>
<tr class="separator:a8111464ced8f5fc3d201a2a0c8f4ca5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a863fe57c851c3c281943fb1f3973de82"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::unique_ptr&lt; <a class="el" href="classsplat_1_1DataTable.html">DataTable</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesplat.html#a863fe57c851c3c281943fb1f3973de82">readLcc</a> (const std::string &amp;filename, const std::string &amp;sourceName, const std::vector&lt; int &gt; &amp;options)</td></tr>
<tr class="separator:a863fe57c851c3c281943fb1f3973de82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77c9b8882c8228988d09532ac3a7e078"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesplat.html#a77c9b8882c8228988d09532ac3a7e078">writeLod</a> (const std::string &amp;filename, const <a class="el" href="classsplat_1_1DataTable.html">DataTable</a> *dataTable, <a class="el" href="classsplat_1_1DataTable.html">DataTable</a> *envDataTable, bool bundle, int iterations, size_t lodChunkCount, size_t lodChunkExtent)</td></tr>
<tr class="separator:a77c9b8882c8228988d09532ac3a7e078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c5aab9390912cf5d71af220b340f09b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classsplat_1_1DataTable.html">DataTable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesplat.html#a9c5aab9390912cf5d71af220b340f09b">readPly</a> (const std::string &amp;filename)</td></tr>
<tr class="memdesc:a9c5aab9390912cf5d71af220b340f09b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads and parses a PLY (Polygon File Format) file from disk.  <a href="namespacesplat.html#a9c5aab9390912cf5d71af220b340f09b">More...</a><br /></td></tr>
<tr class="separator:a9c5aab9390912cf5d71af220b340f09b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac139203466e1fd7c045852504ef676a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesplat.html#ac139203466e1fd7c045852504ef676a6">writePly</a> (const std::string &amp;filename, const <a class="el" href="structsplat_1_1PlyData.html">PlyData</a> &amp;plyData)</td></tr>
<tr class="separator:ac139203466e1fd7c045852504ef676a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36751c18195c40aa9ce84448e9c60c29"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classsplat_1_1DataTable.html">DataTable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesplat.html#a36751c18195c40aa9ce84448e9c60c29">readSog</a> (const std::string &amp;file, const std::string &amp;sourceName)</td></tr>
<tr class="memdesc:a36751c18195c40aa9ce84448e9c60c29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads and parses a Gaussian Splatting (.sog) file into a <a class="el" href="classsplat_1_1DataTable.html" title="Tabular data structure with typed columns.">DataTable</a>.  <a href="namespacesplat.html#a36751c18195c40aa9ce84448e9c60c29">More...</a><br /></td></tr>
<tr class="separator:a36751c18195c40aa9ce84448e9c60c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbfc654461a051b75a3356c5376e5e9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesplat.html#afbfc654461a051b75a3356c5376e5e9d">writeSog</a> (const std::string &amp;filename, <a class="el" href="classsplat_1_1DataTable.html">DataTable</a> *dataTable, bool bundle, int iterations, const std::vector&lt; uint32_t &gt; &amp;indices={})</td></tr>
<tr class="separator:afbfc654461a051b75a3356c5376e5e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c7242ade76de864daa0eb64b9d36848"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classsplat_1_1DataTable.html">DataTable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesplat.html#a7c7242ade76de864daa0eb64b9d36848">readSplat</a> (const std::string &amp;filename)</td></tr>
<tr class="memdesc:a7c7242ade76de864daa0eb64b9d36848"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads and parses a .splat file containing Gaussian splatting data.  <a href="namespacesplat.html#a7c7242ade76de864daa0eb64b9d36848">More...</a><br /></td></tr>
<tr class="separator:a7c7242ade76de864daa0eb64b9d36848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b7809477624d084e15c34b97faeeda1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesplat.html#a9b7809477624d084e15c34b97faeeda1">writeSplat</a> (const <a class="el" href="classsplat_1_1DataTable.html">DataTable</a> *datatable, const std::string &amp;filepath)</td></tr>
<tr class="memdesc:a9b7809477624d084e15c34b97faeeda1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes 3D Gaussian splatting data to a .splat file format.  <a href="namespacesplat.html#a9b7809477624d084e15c34b97faeeda1">More...</a><br /></td></tr>
<tr class="separator:a9b7809477624d084e15c34b97faeeda1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ce2054951931469676ca03b8dea87b3"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classsplat_1_1DataTable.html">DataTable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesplat.html#a5ce2054951931469676ca03b8dea87b3">readSpz</a> (const std::string &amp;filename)</td></tr>
<tr class="separator:a5ce2054951931469676ca03b8dea87b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2686ec942666307e6b7bcb92fd52d7e4"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classsplat_1_1DataTable.html">DataTable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesplat.html#a2686ec942666307e6b7bcb92fd52d7e4">readVoxel</a> (const std::string &amp;filename)</td></tr>
<tr class="separator:a2686ec942666307e6b7bcb92fd52d7e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab34820a32a7f5d0d6a0657c8b8321601"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesplat.html#ab34820a32a7f5d0d6a0657c8b8321601">writeVoxel</a> (const std::string &amp;filename, const <a class="el" href="classsplat_1_1DataTable.html">DataTable</a> *dataTable, float voxelResolution=0.05f, float opacityCutoff=0.5f)</td></tr>
<tr class="separator:ab34820a32a7f5d0d6a0657c8b8321601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6602a59955c1f74cc96dcb84bd4b3b5b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6602a59955c1f74cc96dcb84bd4b3b5b"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesplat.html#a6602a59955c1f74cc96dcb84bd4b3b5b">sigmoid</a> (T x)</td></tr>
<tr class="memdesc:a6602a59955c1f74cc96dcb84bd4b3b5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sigmoid activation function.  <a href="namespacesplat.html#a6602a59955c1f74cc96dcb84bd4b3b5b">More...</a><br /></td></tr>
<tr class="separator:a6602a59955c1f74cc96dcb84bd4b3b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5c99d995d33cde611bffa16444a8839"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesplat.html#af5c99d995d33cde611bffa16444a8839">simple_random</a> ()</td></tr>
<tr class="memdesc:af5c99d995d33cde611bffa16444a8839"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple deterministic pseudo-random number generator.  <a href="namespacesplat.html#af5c99d995d33cde611bffa16444a8839">More...</a><br /></td></tr>
<tr class="separator:af5c99d995d33cde611bffa16444a8839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae744e2d1a1ebc871c56abfa225b63452"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesplat.html#ae744e2d1a1ebc871c56abfa225b63452">isSolid</a> (uint32_t lo, uint32_t hi)</td></tr>
<tr class="separator:ae744e2d1a1ebc871c56abfa225b63452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bd91a7ecdb3d07ca5ebd69924d3f0b0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesplat.html#a2bd91a7ecdb3d07ca5ebd69924d3f0b0">isEmpty</a> (uint32_t lo, uint32_t hi)</td></tr>
<tr class="separator:a2bd91a7ecdb3d07ca5ebd69924d3f0b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c4c710a92c411d950f720a41daee06"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesplat.html#ae0c4c710a92c411d950f720a41daee06">getChildOffset</a> (uint8_t mask, int octant)</td></tr>
<tr class="separator:ae0c4c710a92c411d950f720a41daee06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a207d8f02958f0cda7b5886d6da5696ea"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classsplat_1_1DataTable.html">DataTable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesplat.html#a207d8f02958f0cda7b5886d6da5696ea">combine</a> (std::vector&lt; std::unique_ptr&lt; <a class="el" href="classsplat_1_1DataTable.html">DataTable</a> &gt;&gt; &amp;dataTables)</td></tr>
<tr class="memdesc:a207d8f02958f0cda7b5886d6da5696ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges multiple DataTables into a single combined table.  <a href="namespacesplat.html#a207d8f02958f0cda7b5886d6da5696ea">More...</a><br /></td></tr>
<tr class="separator:a207d8f02958f0cda7b5886d6da5696ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b1201667e39d13f89d4c244c9ddae1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesplat.html#a5b1201667e39d13f89d4c244c9ddae1e">sortByVisibility</a> (const <a class="el" href="classsplat_1_1DataTable.html">DataTable</a> *dataTable, std::vector&lt; unsigned int &gt; &amp;indices)</td></tr>
<tr class="separator:a5b1201667e39d13f89d4c244c9ddae1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9370a258a80d896424204bb4bd445d87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesplat.html#a9370a258a80d896424204bb4bd445d87">sortMortonOrder</a> (const <a class="el" href="classsplat_1_1DataTable.html">DataTable</a> *dataTable, absl::Span&lt; uint32_t &gt; indices)</td></tr>
<tr class="memdesc:a9370a258a80d896424204bb4bd445d87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort Gaussian splats in Morton order (Z-order curve) for memory locality.  <a href="namespacesplat.html#a9370a258a80d896424204bb4bd445d87">More...</a><br /></td></tr>
<tr class="separator:a9370a258a80d896424204bb4bd445d87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf971cb7695dc254563fdd7694df304d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesplat.html#adf971cb7695dc254563fdd7694df304d">xyzToMorton</a> (int x, int y, int z)</td></tr>
<tr class="separator:adf971cb7695dc254563fdd7694df304d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2907b5923ec327bb137eebfa7ae4ae2c"><td class="memItemLeft" align="right" valign="top">std::array&lt; int, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesplat.html#a2907b5923ec327bb137eebfa7ae4ae2c">mortonToXYZ</a> (unsigned int m)</td></tr>
<tr class="separator:a2907b5923ec327bb137eebfa7ae4ae2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1ffc5784d0e8d693134214bf31c3c96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsplat_1_1SummaryData.html">SummaryData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesplat.html#aa1ffc5784d0e8d693134214bf31c3c96">computeSummary</a> (const <a class="el" href="classsplat_1_1DataTable.html">DataTable</a> *dataTable)</td></tr>
<tr class="separator:aa1ffc5784d0e8d693134214bf31c3c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a365a879a34fe2750bdf3dfc693a877e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesplat.html#a365a879a34fe2750bdf3dfc693a877e0">transform</a> (<a class="el" href="classsplat_1_1DataTable.html">DataTable</a> *dataTable, const Eigen::Vector3f &amp;t, const Eigen::Quaternionf &amp;r, float s)</td></tr>
<tr class="memdesc:a365a879a34fe2750bdf3dfc693a877e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply transformation to data table.  <a href="namespacesplat.html#a365a879a34fe2750bdf3dfc693a877e0">More...</a><br /></td></tr>
<tr class="separator:a365a879a34fe2750bdf3dfc693a877e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00c58f1abf4494356213355ca9089561"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsplat_1_1BlockAccumulator.html">BlockAccumulator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesplat.html#a00c58f1abf4494356213355ca9089561">filterAndFillBlocks</a> (const <a class="el" href="structsplat_1_1BlockAccumulator.html">BlockAccumulator</a> &amp;accumulator)</td></tr>
<tr class="separator:a00c58f1abf4494356213355ca9089561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cee29b85e8ff6f57925f2287bb89372"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsplat_1_1GaussianExtentsResult.html">GaussianExtentsResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesplat.html#a3cee29b85e8ff6f57925f2287bb89372">computeGaussianExtents</a> (const <a class="el" href="classsplat_1_1DataTable.html">DataTable</a> *dataTable)</td></tr>
<tr class="separator:a3cee29b85e8ff6f57925f2287bb89372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a535aec4b0840292ef644ac602f527793"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::unique_ptr&lt; <a class="el" href="classsplat_1_1DataTable.html">DataTable</a> &gt;, std::vector&lt; uint32_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesplat.html#a535aec4b0840292ef644ac602f527793">kmeans</a> (<a class="el" href="classsplat_1_1DataTable.html">DataTable</a> *points, size_t k, size_t iterations)</td></tr>
<tr class="separator:a535aec4b0840292ef644ac602f527793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c0b1c0f38ed51c1c576bd1158ac4aeb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsplat_1_1SparseOctree.html">SparseOctree</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesplat.html#a5c0b1c0f38ed51c1c576bd1158ac4aeb">buildSparseOctree</a> (const <a class="el" href="structsplat_1_1BlockAccumulator.html">BlockAccumulator</a> &amp;accumulator, const <a class="el" href="structsplat_1_1Bounds.html">Bounds</a> &amp;gridBounds, const <a class="el" href="structsplat_1_1Bounds.html">Bounds</a> &amp;sceneBounds, double voxelResolution)</td></tr>
<tr class="separator:a5c0b1c0f38ed51c1c576bd1158ac4aeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a3468c7dd0900735d8f61c1a6bdb0146f"><td class="memItemLeft" align="right" valign="top">static constexpr uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesplat.html#a3468c7dd0900735d8f61c1a6bdb0146f">SOLID_MASK</a> = 0xFFFFFFFFu</td></tr>
<tr class="separator:a3468c7dd0900735d8f61c1a6bdb0146f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1316c487551abcdb519cc204af985e21"><td class="memItemLeft" align="right" valign="top">static constexpr uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesplat.html#a1316c487551abcdb519cc204af985e21">SOLID_LEAF_MARKER</a> = 0xFF000000u</td></tr>
<tr class="separator:a1316c487551abcdb519cc204af985e21"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a034ac2e2d75dce80bc73c9188bff5e18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a034ac2e2d75dce80bc73c9188bff5e18">&#9670;&nbsp;</a></span>Row</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacesplat.html#a034ac2e2d75dce80bc73c9188bff5e18">splat::Row</a> = typedef std::map&lt;std::string, float&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents a single row of data as a map of column names to float values. </p>

</div>
</div>
<a id="a15efefd4b08a86eb5541d30becb14627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15efefd4b08a86eb5541d30becb14627">&#9670;&nbsp;</a></span>TypedArray</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacesplat.html#a15efefd4b08a86eb5541d30becb14627">splat::TypedArray</a> = typedef std::variant&lt;std::vector&lt;int8_t&gt;, std::vector&lt;uint8_t&gt;, std::vector&lt;int16_t&gt;, std::vector&lt;uint16_t&gt;, std::vector&lt;int32_t&gt;, std::vector&lt;uint32_t&gt;, std::vector&lt;float&gt;, std::vector&lt;double&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variant type representing different typed array storage options. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a382cd5d5a35ce21b5ae92ab9821c849c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a382cd5d5a35ce21b5ae92ab9821c849c">&#9670;&nbsp;</a></span>ColumnType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacesplat.html#a382cd5d5a35ce21b5ae92ab9821c849c">splat::ColumnType</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration of supported column data types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a382cd5d5a35ce21b5ae92ab9821c849caee9d73311ff0658494edfff14c3ec1e3"></a>INT8&#160;</td><td class="fielddoc"><p>Signed 8-bit integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="a382cd5d5a35ce21b5ae92ab9821c849caecfc091ed2a607335524c8389cfa41b5"></a>UINT8&#160;</td><td class="fielddoc"><p>Unsigned 8-bit integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="a382cd5d5a35ce21b5ae92ab9821c849ca5f90af42814c0a419d715d43ae54fd7a"></a>INT16&#160;</td><td class="fielddoc"><p>Signed 16-bit integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="a382cd5d5a35ce21b5ae92ab9821c849ca48d8f1a723d44ff4a87db1bb6c551c62"></a>UINT16&#160;</td><td class="fielddoc"><p>Unsigned 16-bit integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="a382cd5d5a35ce21b5ae92ab9821c849ca6495adba09844fac8eeb0aba86e6f1bf"></a>INT32&#160;</td><td class="fielddoc"><p>Signed 32-bit integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="a382cd5d5a35ce21b5ae92ab9821c849ca17266551181f69a1b4a3ad5c9e270afc"></a>UINT32&#160;</td><td class="fielddoc"><p>Unsigned 32-bit integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="a382cd5d5a35ce21b5ae92ab9821c849ca967d280b5c16d95f2947647dd2ca6cc2"></a>FLOAT32&#160;</td><td class="fielddoc"><p>32-bit floating point </p>
</td></tr>
<tr><td class="fieldname"><a id="a382cd5d5a35ce21b5ae92ab9821c849ca139882c654db8a57f7c3092de1dd0b02"></a>FLOAT64&#160;</td><td class="fielddoc"><p>64-bit floating point </p>
</td></tr>
</table>

</div>
</div>
<a id="a06e7c2f7ae07b287f4c45ed56d387579"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06e7c2f7ae07b287f4c45ed56d387579">&#9670;&nbsp;</a></span>logLevel</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacesplat.html#a06e7c2f7ae07b287f4c45ed56d387579">splat::logLevel</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a06e7c2f7ae07b287f4c45ed56d387579a73be252ca82217b1458a25e6b4e99f15"></a>silent&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a06e7c2f7ae07b287f4c45ed56d387579afea087517c26fadd409bd4b9dc642555"></a>normal&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a5c0b1c0f38ed51c1c576bd1158ac4aeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c0b1c0f38ed51c1c576bd1158ac4aeb">&#9670;&nbsp;</a></span>buildSparseOctree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsplat_1_1SparseOctree.html">SparseOctree</a> splat::buildSparseOctree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsplat_1_1BlockAccumulator.html">BlockAccumulator</a> &amp;&#160;</td>
          <td class="paramname"><em>accumulator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsplat_1_1Bounds.html">Bounds</a> &amp;&#160;</td>
          <td class="paramname"><em>gridBounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsplat_1_1Bounds.html">Bounds</a> &amp;&#160;</td>
          <td class="paramname"><em>sceneBounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>voxelResolution</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Build a sparse octree from accumulated voxelization blocks.</p>
<p>Uses Structure-of-Arrays (SoA) representation and linear scans on sorted Morton codes instead of Maps and per-node objects for performance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">accumulator</td><td>- <a class="el" href="structsplat_1_1BlockAccumulator.html">BlockAccumulator</a> containing voxelized blocks </td></tr>
    <tr><td class="paramname">gridBounds</td><td>- Grid bounds aligned to block boundaries </td></tr>
    <tr><td class="paramname">sceneBounds</td><td>- Original scene bounds </td></tr>
    <tr><td class="paramname">voxelResolution</td><td>- Size of each voxel in world units </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sparse octree structure </dd></dl>

</div>
</div>
<a id="a207d8f02958f0cda7b5886d6da5696ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a207d8f02958f0cda7b5886d6da5696ea">&#9670;&nbsp;</a></span>combine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classsplat_1_1DataTable.html">DataTable</a>&gt; splat::combine </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::unique_ptr&lt; <a class="el" href="classsplat_1_1DataTable.html">DataTable</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>dataTables</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges multiple DataTables into a single combined table. </p>
<p>Creates a union of columns (by name and type) and concatenates rows. Input tables are consumed (moved from) during the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataTables</td><td>Tables to combine (will be emptied) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Merged table, or nullptr if input is empty </dd></dl>

</div>
</div>
<a id="a3cee29b85e8ff6f57925f2287bb89372"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cee29b85e8ff6f57925f2287bb89372">&#9670;&nbsp;</a></span>computeGaussianExtents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsplat_1_1GaussianExtentsResult.html">GaussianExtentsResult</a> splat::computeGaussianExtents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsplat_1_1DataTable.html">DataTable</a> *&#160;</td>
          <td class="paramname"><em>dataTable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute axis-aligned bounding box half-extents for all Gaussians in a <a class="el" href="classsplat_1_1DataTable.html" title="Tabular data structure with typed columns.">DataTable</a>.</p>
<p>Each Gaussian is an oriented ellipsoid defined by position, rotation (quaternion), and scale (log scale). This function computes the AABB that encloses each rotated ellipsoid and stores only the half-extents. The full AABB can be reconstructed at runtime using: min = position - extent, max = position + extent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataTable</td><td>- <a class="el" href="classsplat_1_1DataTable.html" title="Tabular data structure with typed columns.">DataTable</a> containing Gaussian splat data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structsplat_1_1GaussianExtentsResult.html">GaussianExtentsResult</a> with extents <a class="el" href="classsplat_1_1DataTable.html" title="Tabular data structure with typed columns.">DataTable</a> and scene bounds </dd></dl>

</div>
</div>
<a id="aa1ffc5784d0e8d693134214bf31c3c96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1ffc5784d0e8d693134214bf31c3c96">&#9670;&nbsp;</a></span>computeSummary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsplat_1_1SummaryData.html">SummaryData</a> splat::computeSummary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsplat_1_1DataTable.html">DataTable</a> *&#160;</td>
          <td class="paramname"><em>dataTable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa252f193c70195f18e271769fa16e2ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa252f193c70195f18e271769fa16e2ad">&#9670;&nbsp;</a></span>decompressPly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classsplat_1_1DataTable.html">DataTable</a>&gt; splat::decompressPly </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsplat_1_1PlyData.html">PlyData</a> *&#160;</td>
          <td class="paramname"><em>ply</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a00c58f1abf4494356213355ca9089561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00c58f1abf4494356213355ca9089561">&#9670;&nbsp;</a></span>filterAndFillBlocks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsplat_1_1BlockAccumulator.html">BlockAccumulator</a> splat::filterAndFillBlocks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsplat_1_1BlockAccumulator.html">BlockAccumulator</a> &amp;&#160;</td>
          <td class="paramname"><em>accumulator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove isolated voxels and fill isolated empty voxels within mixed blocks.</p>
<p>For each mixed block, computes 6 per-direction occupancy masks (in-block via bit shifts + cross-block via adjacent block lookups), then:</p><ul>
<li>Remove: keeps only voxels with at least one occupied 6-connected neighbor</li>
<li>Fill: fills empty voxels where all 6 neighbors are occupied</li>
</ul>
<p>Blocks that become empty or solid as a consequence are handled automatically.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">accumulator</td><td>- <a class="el" href="structsplat_1_1BlockAccumulator.html">BlockAccumulator</a> with voxelization results </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New <a class="el" href="structsplat_1_1BlockAccumulator.html">BlockAccumulator</a> with filtered/filled data </dd></dl>

</div>
</div>
<a id="ae0c4c710a92c411d950f720a41daee06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0c4c710a92c411d950f720a41daee06">&#9670;&nbsp;</a></span>getChildOffset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t splat::getChildOffset </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>octant</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the offset to a child node given a parent's child mask and octant. Uses absl::popcount to count how many children come before this octant.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>- 8-bit child mask from parent node </td></tr>
    <tr><td class="paramname">octant</td><td>- Octant index (0-7) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Offset from base child pointer </dd></dl>

</div>
</div>
<a id="a07152f181a31a582c288178ffc5f9546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07152f181a31a582c288178ffc5f9546">&#9670;&nbsp;</a></span>isCompressedPly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool splat::isCompressedPly </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsplat_1_1PlyData.html">PlyData</a> *&#160;</td>
          <td class="paramname"><em>ply</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2bd91a7ecdb3d07ca5ebd69924d3f0b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bd91a7ecdb3d07ca5ebd69924d3f0b0">&#9670;&nbsp;</a></span>isEmpty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool splat::isEmpty </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>hi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if a voxel mask represents an empty block (no bits set).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lo</td><td>- Lower 32 bits of mask </td></tr>
    <tr><td class="paramname">hi</td><td>- Upper 32 bits of mask </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if all 64 voxels are empty </dd></dl>

</div>
</div>
<a id="ae744e2d1a1ebc871c56abfa225b63452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae744e2d1a1ebc871c56abfa225b63452">&#9670;&nbsp;</a></span>isSolid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool splat::isSolid </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>hi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if a voxel mask represents a solid block (all 64 bits set).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lo</td><td>- Lower 32 bits of mask </td></tr>
    <tr><td class="paramname">hi</td><td>- Upper 32 bits of mask </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if all 64 voxels are solid </dd></dl>

</div>
</div>
<a id="a535aec4b0840292ef644ac602f527793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a535aec4b0840292ef644ac602f527793">&#9670;&nbsp;</a></span>kmeans()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::unique_ptr&lt;<a class="el" href="classsplat_1_1DataTable.html">DataTable</a>&gt;, std::vector&lt;uint32_t&gt; &gt; splat::kmeans </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsplat_1_1DataTable.html">DataTable</a> *&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iterations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2907b5923ec327bb137eebfa7ae4ae2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2907b5923ec327bb137eebfa7ae4ae2c">&#9670;&nbsp;</a></span>mortonToXYZ()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;int, 3&gt; splat::mortonToXYZ </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Decode Morton code to block coordinates.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>- Morton code </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array of [x, y, z] block coordinates </dd></dl>

</div>
</div>
<a id="a8111464ced8f5fc3d201a2a0c8f4ca5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8111464ced8f5fc3d201a2a0c8f4ca5b">&#9670;&nbsp;</a></span>readKsplat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classsplat_1_1DataTable.html">DataTable</a>&gt; splat::readKsplat </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a863fe57c851c3c281943fb1f3973de82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a863fe57c851c3c281943fb1f3973de82">&#9670;&nbsp;</a></span>readLcc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::unique_ptr&lt;<a class="el" href="classsplat_1_1DataTable.html">DataTable</a>&gt; &gt; splat::readLcc </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sourceName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9c5aab9390912cf5d71af220b340f09b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c5aab9390912cf5d71af220b340f09b">&#9670;&nbsp;</a></span>readPly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classsplat_1_1DataTable.html">DataTable</a>&gt; splat::readPly </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads and parses a PLY (Polygon File Format) file from disk. </p>
<p>This function loads a PLY file, parses its header and data sections, and returns a <a class="el" href="classsplat_1_1DataTable.html" title="Tabular data structure with typed columns.">DataTable</a> containing the vertex data. The function supports both ASCII and binary PLY formats and handles data in chunks for memory efficiency.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>Path to the PLY file to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::unique_ptr&lt;DataTable&gt; A smart pointer to a <a class="el" href="classsplat_1_1DataTable.html" title="Tabular data structure with typed columns.">DataTable</a> containing the vertex data from the PLY file. If the file contains compressed data, it will be decompressed automatically.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If:<ul>
<li>The file cannot be opened</li>
<li>The file header is invalid or missing the PLY magic bytes</li>
<li>The header exceeds the maximum size (128KB)</li>
<li>The 'end_header' marker is not found</li>
<li>Data chunks cannot be read properly</li>
<li>The file does not contain a vertex element</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The function reads data in chunks of 1024 rows at a time to optimize memory usage. Non-vertex elements are stored in the <a class="el" href="structsplat_1_1PlyData.html" title="Complete in-memory representation of PLY file data.">PlyData</a> structure but only vertex data is returned. If the PLY data is compressed, it will be decompressed before returning.</dd></dl>
<dl class="section user"><dt>File Format Support:</dt><dd><ul>
<li>Binary PLY format (little-endian)</li>
<li>Structured elements with properties</li>
<li>Optional compression (automatically detected and decompressed)</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd>parseHeader() For header parsing details </dd>
<dd>
<a class="el" href="namespacesplat.html#a07152f181a31a582c288178ffc5f9546">isCompressedPly()</a> For compression detection </dd>
<dd>
<a class="el" href="namespacesplat.html#aa252f193c70195f18e271769fa16e2ad">decompressPly()</a> For decompression logic </dd></dl>

</div>
</div>
<a id="a36751c18195c40aa9ce84448e9c60c29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36751c18195c40aa9ce84448e9c60c29">&#9670;&nbsp;</a></span>readSog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classsplat_1_1DataTable.html">DataTable</a>&gt; splat::readSog </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sourceName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads and parses a Gaussian Splatting (.sog) file into a <a class="el" href="classsplat_1_1DataTable.html" title="Tabular data structure with typed columns.">DataTable</a>. </p>
<p>This function loads and decodes a Gaussian Splatting scene stored in .sog format. The .sog format is a compressed representation of Gaussian splatting data that stores position, scale, color, rotation, and optionally higher-order spherical harmonics in an efficient texture-based encoding.</p>
<p>The function supports two input modes:</p><ol type="1">
<li>Reading from a single .sog ZIP archive file containing all components</li>
<li>Reading from individual component files in a directory structure</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>Path to the main .sog file or directory containing component files </td></tr>
    <tr><td class="paramname">sourceName</td><td>Source name/path used to locate component files. If sourceName ends with ".sog", the function treats it as a ZIP archive. Otherwise, it treats sourceName as a directory containing individual component files.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::unique_ptr&lt;DataTable&gt; containing the decoded Gaussian splatting data. The <a class="el" href="classsplat_1_1DataTable.html" title="Tabular data structure with typed columns.">DataTable</a> contains the following columns (at minimum):<ul>
<li>x, y, z: 3D positions (float)</li>
<li>scale_0, scale_1, scale_2: 3D scale factors (float)</li>
<li>f_dc_0, f_dc_1, f_dc_2: Spherical harmonic band 0 coefficients (RGB colors, float)</li>
<li>opacity: Opacity values (float)</li>
<li>rot_0, rot_1, rot_2, rot_3: Rotation quaternions (float) Additional columns for higher-order spherical harmonics (f_rest_*) are added if present in the source data.</li>
</ul>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if:<ul>
<li>The .sog file or component files cannot be opened/read</li>
<li>Required metadata (meta.json) is missing or invalid</li>
<li>Texture dimensions are insufficient for the declared splat count</li>
<li>File format inconsistencies are detected</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The function performs parallel processing using OpenMP for performance </dd>
<dd>
Position coordinates are transformed using invLogTransform to restore the original coordinate space </dd>
<dd>
Scale factors are decoded from a codebook-based quantization </dd>
<dd>
Rotation quaternions are unpacked from a compressed 8-bit per channel representation </dd>
<dd>
Colors and opacity are decoded from quantized SH0 coefficients with sigmoid inverse transformation for opacity </dd>
<dd>
Higher-order spherical harmonics (bands &gt; 0) are optionally decoded if present in the metadata</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structsplat_1_1Meta.html#a57e714c62a253e91c74bb5a24eee2265" title="Parse metadata from JSON byte array.">Meta::parseFromJson</a> </dd>
<dd>
decodeMeans </dd>
<dd>
unpackQuat </dd>
<dd>
invLogTransform </dd>
<dd>
sigmoidInv </dd></dl>

</div>
</div>
<a id="a7c7242ade76de864daa0eb64b9d36848"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c7242ade76de864daa0eb64b9d36848">&#9670;&nbsp;</a></span>readSplat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classsplat_1_1DataTable.html">DataTable</a>&gt; splat::readSplat </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads and parses a .splat file containing Gaussian splatting data. </p>
<p>This function loads a binary .splat file containing uncompressed Gaussian splatting data. Each splat is represented as a fixed 32-byte structure containing position, scale, color, opacity, and rotation data. The file format is a simple concatenation of these 32-byte records.</p>
<p>The .splat format stores data in the following layout per splat (all little-endian):</p><ul>
<li>Bytes 0-11: Position (x, y, z) as 3  float32</li>
<li>Bytes 12-23: Scale (sx, sy, sz) as 3  float32</li>
<li>Bytes 24-27: Color and opacity as 4  uint8 (RGBA format)</li>
<li>Bytes 28-31: Rotation quaternion as 4  uint8</li>
</ul>
<p>The function performs necessary conversions during loading:</p><ul>
<li>Position coordinates are used directly as float32 values</li>
<li>Scale factors are converted from linear to logarithmic space (logf)</li>
<li>Color values are converted from uint8 [0,255] range to spherical harmonic coefficients</li>
<li>Opacity values are converted from uint8 to float with inverse sigmoid transformation</li>
<li>Rotation quaternions are unpacked from uint8 representation and normalized</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Path to the .splat file to read</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::unique_ptr&lt;DataTable&gt; containing the parsed Gaussian splatting data. The <a class="el" href="classsplat_1_1DataTable.html" title="Tabular data structure with typed columns.">DataTable</a> contains exactly 14 columns in the following order:<ol type="1">
<li>x (float): X-coordinate position</li>
<li>y (float): Y-coordinate position</li>
<li>z (float): Z-coordinate position</li>
<li>scale_0 (float): Logarithm of first scale component (log scale)</li>
<li>scale_1 (float): Logarithm of second scale component (log scale)</li>
<li>scale_2 (float): Logarithm of third scale component (log scale)</li>
<li>f_dc_0 (float): Spherical harmonic DC term for red channel</li>
<li>f_dc_1 (float): Spherical harmonic DC term for green channel</li>
<li>f_dc_2 (float): Spherical harmonic DC term for blue channel</li>
<li>opacity (float): Opacity after inverse sigmoid transformation</li>
<li>rot_0 (float): First component of normalized rotation quaternion</li>
<li>rot_1 (float): Second component of normalized rotation quaternion</li>
<li>rot_2 (float): Third component of normalized rotation quaternion</li>
<li>rot_3 (float): Fourth component of normalized rotation quaternion</li>
</ol>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if:<ul>
<li>The file cannot be opened or does not exist</li>
<li>File size is not a multiple of 32 bytes (invalid format)</li>
<li>File is empty (0 bytes)</li>
<li>Failed to read expected amount of data during chunked reading</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The function reads data in chunks of 1024 splats (32KB) for memory efficiency </dd>
<dd>
Scale factors are stored as linear values in the file but converted to log scale internally for numerical stability in Gaussian computations </dd>
<dd>
Color conversion uses the spherical harmonic C0 constant (0.28209479177387814) to transform uint8 values to proper SH coefficients </dd>
<dd>
Invalid rotation quaternions (zero length) are replaced with identity quaternion [0,0,0,1] </dd>
<dd>
This format does not support higher-order spherical harmonics (SH bands &gt; 0)</dd></dl>
<dl class="section see"><dt>See also</dt><dd>BYTES_PER_SPLAT for the fixed record size </dd>
<dd>
readFloatLE for little-endian float reading </dd>
<dd>
readUInt8 for byte reading </dd></dl>

</div>
</div>
<a id="a5ce2054951931469676ca03b8dea87b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ce2054951931469676ca03b8dea87b3">&#9670;&nbsp;</a></span>readSpz()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classsplat_1_1DataTable.html">DataTable</a>&gt; splat::readSpz </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2686ec942666307e6b7bcb92fd52d7e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2686ec942666307e6b7bcb92fd52d7e4">&#9670;&nbsp;</a></span>readVoxel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classsplat_1_1DataTable.html">DataTable</a>&gt; splat::readVoxel </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a .voxel.json file and convert to <a class="el" href="classsplat_1_1DataTable.html" title="Tabular data structure with typed columns.">DataTable</a> (finest/leaf LOD).</p>
<p>Loads the voxel octree from .voxel.json + .voxel.bin, traverses to the leaf level, and outputs a <a class="el" href="classsplat_1_1DataTable.html" title="Tabular data structure with typed columns.">DataTable</a> in the same Gaussian splat format as voxel-octree-node.mjs at the leaf level. Users can then save to PLY, CSV, or any other format.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileSystem</td><td>- File system for reading files </td></tr>
    <tr><td class="paramname">filename</td><td>- Path to .voxel.json (the .voxel.bin must exist alongside it) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classsplat_1_1DataTable.html" title="Tabular data structure with typed columns.">DataTable</a> with voxel block centers as Gaussian splats </dd></dl>

</div>
</div>
<a id="a6602a59955c1f74cc96dcb84bd4b3b5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6602a59955c1f74cc96dcb84bd4b3b5b">&#9670;&nbsp;</a></span>sigmoid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T splat::sigmoid </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sigmoid activation function. </p>
<p>Computes the sigmoid (logistic) function: (x) = 1 / (1 + exp(-x)) This function maps real values to the range (0, 1) and is commonly used in machine learning for probabilities and activations.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Numeric type (float, double, etc.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Input value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sigmoid-transformed value in range (0, 1)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For Gaussian splatting, this is typically used to convert raw opacity values to valid opacity in [0, 1] range. </dd>
<dd>
Uses double-precision exponential for accuracy even with float input. </dd></dl>

</div>
</div>
<a id="af5c99d995d33cde611bffa16444a8839"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5c99d995d33cde611bffa16444a8839">&#9670;&nbsp;</a></span>simple_random()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float splat::simple_random </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simple deterministic pseudo-random number generator. </p>
<p>Generates a pseudo-random float in the range [0, 1) using a linear congruential generator (LCG). The generator is deterministic and thread-unsafe due to static internal state.</p>
<dl class="section return"><dt>Returns</dt><dd>Random float in range [0, 1)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a simple PRNG suitable for debugging, testing, or situations where reproducibility is more important than statistical quality. </dd>
<dd>
Not suitable for cryptographic or high-quality statistical applications. </dd>
<dd>
The generator uses the constants from POSIX rand() implementation: multiplier = 1103515245, increment = 12345, modulus = 2^31. </dd>
<dd>
Thread-unsafe: uses static internal state. </dd></dl>
<p>&lt; Initial seed (can be changed for different sequences)</p>

</div>
</div>
<a id="a5b1201667e39d13f89d4c244c9ddae1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b1201667e39d13f89d4c244c9ddae1e">&#9670;&nbsp;</a></span>sortByVisibility()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void splat::sortByVisibility </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsplat_1_1DataTable.html">DataTable</a> *&#160;</td>
          <td class="paramname"><em>dataTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sorts the provided indices by visibility score (descending order).</p>
<p>Visibility is computed as: linear_opacity * volume where:</p><ul>
<li>linear_opacity = sigmoid(opacity) = 1 / (1 + exp(-opacity))</li>
<li>volume = exp(scale_0) * exp(scale_1) * exp(scale_2)</li>
</ul>
<p>After calling this function, indices[0] will contain the index of the most visible splat, indices[1] the second most visible, and so on.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataTable</td><td>- The <a class="el" href="classsplat_1_1DataTable.html" title="Tabular data structure with typed columns.">DataTable</a> containing splat data. </td></tr>
    <tr><td class="paramname">indices</td><td>- Array of indices to sort in-place. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9370a258a80d896424204bb4bd445d87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9370a258a80d896424204bb4bd445d87">&#9670;&nbsp;</a></span>sortMortonOrder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void splat::sortMortonOrder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsplat_1_1DataTable.html">DataTable</a> *&#160;</td>
          <td class="paramname"><em>dataTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; uint32_t &gt;&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort Gaussian splats in Morton order (Z-order curve) for memory locality. </p>
<p>This function computes a Morton ordering (Z-order curve) of the Gaussian splats based on their 3D positions to improve cache locality and memory access patterns. The Morton code interleaves the bits of the 3D coordinates to create a 1D ordering that preserves spatial proximity in multi-dimensional space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataTable</td><td>Pointer to the <a class="el" href="classsplat_1_1DataTable.html" title="Tabular data structure with typed columns.">DataTable</a> containing Gaussian splat data. Expected to have at least 'x', 'y', and 'z' columns representing the 3D positions of the splats. </td></tr>
    <tr><td class="paramname">indices</td><td>Output span that will be filled with the sorted indices in Morton order. Must be pre-allocated with size equal to the number of rows in dataTable. On output, indices[i] contains the original index of the i-th splat in Morton order.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The function assumes the position coordinates are normalized or bounded. </dd>
<dd>
Morton ordering is particularly effective for octree-based rendering and improves performance for spatially coherent operations. </dd>
<dd>
This is a key optimization for real-time Gaussian splatting rendering pipelines. </dd></dl>

</div>
</div>
<a id="a365a879a34fe2750bdf3dfc693a877e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a365a879a34fe2750bdf3dfc693a877e0">&#9670;&nbsp;</a></span>transform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void splat::transform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsplat_1_1DataTable.html">DataTable</a> *&#160;</td>
          <td class="paramname"><em>dataTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Quaternionf &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply transformation to data table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataTable</td><td>Table to transform </td></tr>
    <tr><td class="paramname">t</td><td>Translation vector </td></tr>
    <tr><td class="paramname">r</td><td>Rotation quaternion </td></tr>
    <tr><td class="paramname">s</td><td>Scale factor</td></tr>
  </table>
  </dd>
</dl>
<p>Applies translation, rotation, and scaling transformation to relevant columns in the data table. </p>

</div>
</div>
<a id="aca057d27b7f853b0e501bfffb6f7e971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca057d27b7f853b0e501bfffb6f7e971">&#9670;&nbsp;</a></span>writeCompressedPly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void splat::writeCompressedPly </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsplat_1_1DataTable.html">DataTable</a> *&#160;</td>
          <td class="paramname"><em>dataTable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0bfa1469594d0e1f3077bcf114fa2b11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bfa1469594d0e1f3077bcf114fa2b11">&#9670;&nbsp;</a></span>writeCSV()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void splat::writeCSV </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsplat_1_1DataTable.html">DataTable</a> *&#160;</td>
          <td class="paramname"><em>dataTable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a77c9b8882c8228988d09532ac3a7e078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77c9b8882c8228988d09532ac3a7e078">&#9670;&nbsp;</a></span>writeLod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void splat::writeLod </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsplat_1_1DataTable.html">DataTable</a> *&#160;</td>
          <td class="paramname"><em>dataTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsplat_1_1DataTable.html">DataTable</a> *&#160;</td>
          <td class="paramname"><em>envDataTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bundle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>lodChunkCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>lodChunkExtent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac139203466e1fd7c045852504ef676a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac139203466e1fd7c045852504ef676a6">&#9670;&nbsp;</a></span>writePly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void splat::writePly </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsplat_1_1PlyData.html">PlyData</a> &amp;&#160;</td>
          <td class="paramname"><em>plyData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afbfc654461a051b75a3356c5376e5e9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbfc654461a051b75a3356c5376e5e9d">&#9670;&nbsp;</a></span>writeSog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void splat::writeSog </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsplat_1_1DataTable.html">DataTable</a> *&#160;</td>
          <td class="paramname"><em>dataTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bundle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9b7809477624d084e15c34b97faeeda1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b7809477624d084e15c34b97faeeda1">&#9670;&nbsp;</a></span>writeSplat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void splat::writeSplat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsplat_1_1DataTable.html">DataTable</a> *&#160;</td>
          <td class="paramname"><em>datatable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filepath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes 3D Gaussian splatting data to a .splat file format. </p>
<p>This function converts internal Gaussian splatting data representation to the binary .splat file format, which is optimized for efficient storage and loading. The .splat format stores each Gaussian splat as a 32-byte record containing:</p><ul>
<li>Position (3  float32): x, y, z coordinates</li>
<li>Scale (3  float32): scale factors along each axis (stored as linear values)</li>
<li>Color and opacity (4  uint8): RGB color and alpha opacity</li>
<li>Rotation (4  uint8): Quaternion rotation encoded as normalized bytes</li>
</ul>
<p>The conversion process includes:</p><ul>
<li>Converting log-scale values to linear scale using exp()</li>
<li>Converting spherical harmonic coefficients to RGB color using SH_C0 constant</li>
<li>Applying sigmoid function to opacity values</li>
<li>Normalizing and encoding quaternion rotation to byte range [0, 255]</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">datatable</td><td>Pointer to the <a class="el" href="classsplat_1_1DataTable.html" title="Tabular data structure with typed columns.">DataTable</a> containing Gaussian splat data. Must contain the following columns:<ul>
<li>Position: "x", "y", "z" (float)</li>
<li>Scale: "scale_0", "scale_1", "scale_2" (float, log-scale)</li>
<li>Color: "f_dc_0", "f_dc_1", "f_dc_2" (float, spherical harmonics)</li>
<li>Opacity: "opacity" (float, log-space)</li>
<li>Rotation: "rot_0", "rot_1", "rot_2", "rot_3" (float, quaternion)</li>
</ul>
</td></tr>
    <tr><td class="paramname">filepath</td><td>Output file path where the .splat data will be written. The file will be created or overwritten if it exists.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the file cannot be opened for writing. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>If required columns are missing from the <a class="el" href="classsplat_1_1DataTable.html" title="Tabular data structure with typed columns.">DataTable</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The function writes data in binary format with little-endian byte order. Each splat is written as a 32-byte record, making the total file size predictable: num_splats  32 bytes.</dd>
<dd>
For performance, the function flushes the output stream every 1000 splats to balance memory usage and I/O efficiency.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacesplat.html#a7c7242ade76de864daa0eb64b9d36848" title="Reads and parses a .splat file containing Gaussian splatting data.">readSplat()</a> for reading .<a class="el" href="namespacesplat.html">splat</a> files </dd>
<dd>
<a class="el" href="classsplat_1_1DataTable.html" title="Tabular data structure with typed columns.">DataTable</a> for data structure requirements </dd></dl>

</div>
</div>
<a id="ab34820a32a7f5d0d6a0657c8b8321601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab34820a32a7f5d0d6a0657c8b8321601">&#9670;&nbsp;</a></span>writeVoxel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void splat::writeVoxel </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsplat_1_1DataTable.html">DataTable</a> *&#160;</td>
          <td class="paramname"><em>dataTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>voxelResolution</em> = <code>0.05f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>opacityCutoff</em> = <code>0.5f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Voxelizes Gaussian splat data and writes the result as a sparse voxel octree.</p>
<p>This function performs GPU-accelerated voxelization of Gaussian splat data and outputs two files:</p><ul>
<li><code>filename</code> (.voxel.json) - JSON metadata including bounds, resolution, and array sizes</li>
<li>Corresponding .voxel.bin - Binary octree data (nodes + leafData as uint32_t arrays)</li>
</ul>
<p>The binary file layout is:</p><ul>
<li>Bytes 0 to (nodeCount * 4 - 1): nodes array (uint32_t, little-endian)</li>
<li>Bytes (nodeCount * 4) to end: leafData array (uint32_t, little-endian)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>- Output filename (without extension) or with .voxel.json extension </td></tr>
    <tr><td class="paramname">dataTable</td><td>- Gaussian splat data to voxelize </td></tr>
    <tr><td class="paramname">voxelResolution</td><td>- Size of each voxel in world units. Default: 0.05 </td></tr>
    <tr><td class="paramname">opacityCutoff</td><td>- Opacity threshold for solid voxels - voxels below this are considered empty. Default: 0.5</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if voxelization succeeded, false otherwise</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function requires a GPU that supports compute shaders. </dd></dl>

</div>
</div>
<a id="adf971cb7695dc254563fdd7694df304d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf971cb7695dc254563fdd7694df304d">&#9670;&nbsp;</a></span>xyzToMorton()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t splat::xyzToMorton </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Encode block coordinates to Morton code (17 bits per axis = 51 bits total). Supports up to 131,072 blocks per axis.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>- Block X coordinate </td></tr>
    <tr><td class="paramname">y</td><td>- Block Y coordinate </td></tr>
    <tr><td class="paramname">z</td><td>- Block Z coordinate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Morton code with interleaved bits: ...z2y2x2 z1y1x1 z0y0x0 </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a1316c487551abcdb519cc204af985e21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1316c487551abcdb519cc204af985e21">&#9670;&nbsp;</a></span>SOLID_LEAF_MARKER</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr uint32_t splat::SOLID_LEAF_MARKER = 0xFF000000u</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Solid leaf node marker: childMask = 0xFF, baseOffset = 0. This is unambiguous because BFS layout guarantees children always come after their parent, so baseOffset = 0 is never valid for an interior node. </p>

</div>
</div>
<a id="a3468c7dd0900735d8f61c1a6bdb0146f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3468c7dd0900735d8f61c1a6bdb0146f">&#9670;&nbsp;</a></span>SOLID_MASK</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr uint32_t splat::SOLID_MASK = 0xFFFFFFFFu</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>All 64 bits set (as unsigned 32-bit) </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
