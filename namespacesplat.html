<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SplatLib: splat Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SplatLib
   &#160;<span id="projectnumber">1.3.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">splat Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacesplat_1_1webpcodec"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesplat_1_1webpcodec.html">webpcodec</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsplat_1_1CompressedChunk.html">CompressedChunk</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsplat_1_1RotateSH.html">RotateSH</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotation matrices for spherical harmonics up to band 3.  <a href="structsplat_1_1RotateSH.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsplat_1_1Column.html">Column</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a single column of typed data with metadata.  <a href="structsplat_1_1Column.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsplat_1_1DataTable.html">DataTable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tabular data structure with typed columns.  <a href="classsplat_1_1DataTable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsplat_1_1LccLod.html">LccLod</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsplat_1_1LccUnitInfo.html">LccUnitInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsplat_1_1CompressInfo.html">CompressInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsplat_1_1LccParam.html">LccParam</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsplat_1_1ProcessUnitContext.html">ProcessUnitContext</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsplat_1_1PlyProperty.html">PlyProperty</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a single property definition in a PLY element.  <a href="structsplat_1_1PlyProperty.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsplat_1_1PlyElement.html">PlyElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a PLY element (group of properties) in the header.  <a href="structsplat_1_1PlyElement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsplat_1_1PlyHeader.html">PlyHeader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complete PLY file header information.  <a href="structsplat_1_1PlyHeader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsplat_1_1PlyElementData.html">PlyElementData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains actual data for a PLY element along with its name.  <a href="structsplat_1_1PlyElementData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsplat_1_1PlyData.html">PlyData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complete in-memory representation of PLY file data.  <a href="structsplat_1_1PlyData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsplat_1_1Meta.html">Meta</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metadata structure for Gaussian Splatting data representation.  <a href="structsplat_1_1Meta.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsplat_1_1BTree.html">BTree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bounding Volume Hierarchy (BVH) tree implementation using Axis-Aligned Bounding Boxes (AABBs).  <a href="classsplat_1_1BTree.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsplat_1_1KdTree.html">KdTree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">K-dimensional tree for efficient spatial queries on 3D Gaussian splatting data.  <a href="classsplat_1_1KdTree.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsplat_1_1Octree.html">Octree</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsplat_1_1Crc.html">Crc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsplat_1_1Logger.html">Logger</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsplat_1_1ZipEntry.html">ZipEntry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsplat_1_1ZipReader.html">ZipReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimal ZIP reader supporting STORED (method 0) and data descriptors. It sequentially parses Local File Headers to list entries.  <a href="classsplat_1_1ZipReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsplat_1_1FileInfo.html">FileInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the metadata for a single file entry within the archive.  <a href="structsplat_1_1FileInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsplat_1_1ZipWriter.html">ZipWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous streaming ZIP archive writer.  <a href="classsplat_1_1ZipWriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a034ac2e2d75dce80bc73c9188bff5e18"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesplat.html#a034ac2e2d75dce80bc73c9188bff5e18">Row</a> = std::map&lt; std::string, float &gt;</td></tr>
<tr class="memdesc:a034ac2e2d75dce80bc73c9188bff5e18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a single row of data as a map of column names to float values.  <a href="namespacesplat.html#a034ac2e2d75dce80bc73c9188bff5e18">More...</a><br /></td></tr>
<tr class="separator:a034ac2e2d75dce80bc73c9188bff5e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15efefd4b08a86eb5541d30becb14627"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesplat.html#a15efefd4b08a86eb5541d30becb14627">TypedArray</a> = std::variant&lt; std::vector&lt; int8_t &gt;, std::vector&lt; uint8_t &gt;, std::vector&lt; int16_t &gt;, std::vector&lt; uint16_t &gt;, std::vector&lt; int32_t &gt;, std::vector&lt; uint32_t &gt;, std::vector&lt; float &gt;, std::vector&lt; double &gt; &gt;</td></tr>
<tr class="memdesc:a15efefd4b08a86eb5541d30becb14627"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant type representing different typed array storage options.  <a href="namespacesplat.html#a15efefd4b08a86eb5541d30becb14627">More...</a><br /></td></tr>
<tr class="separator:a15efefd4b08a86eb5541d30becb14627"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a382cd5d5a35ce21b5ae92ab9821c849c"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesplat.html#a382cd5d5a35ce21b5ae92ab9821c849c">ColumnType</a> : uint8_t { <br />
&#160;&#160;<a class="el" href="namespacesplat.html#a382cd5d5a35ce21b5ae92ab9821c849caee9d73311ff0658494edfff14c3ec1e3">INT8</a>
, <a class="el" href="namespacesplat.html#a382cd5d5a35ce21b5ae92ab9821c849caecfc091ed2a607335524c8389cfa41b5">UINT8</a>
, <a class="el" href="namespacesplat.html#a382cd5d5a35ce21b5ae92ab9821c849ca5f90af42814c0a419d715d43ae54fd7a">INT16</a>
, <a class="el" href="namespacesplat.html#a382cd5d5a35ce21b5ae92ab9821c849ca48d8f1a723d44ff4a87db1bb6c551c62">UINT16</a>
, <br />
&#160;&#160;<a class="el" href="namespacesplat.html#a382cd5d5a35ce21b5ae92ab9821c849ca6495adba09844fac8eeb0aba86e6f1bf">INT32</a>
, <a class="el" href="namespacesplat.html#a382cd5d5a35ce21b5ae92ab9821c849ca17266551181f69a1b4a3ad5c9e270afc">UINT32</a>
, <a class="el" href="namespacesplat.html#a382cd5d5a35ce21b5ae92ab9821c849ca967d280b5c16d95f2947647dd2ca6cc2">FLOAT32</a>
, <a class="el" href="namespacesplat.html#a382cd5d5a35ce21b5ae92ab9821c849ca139882c654db8a57f7c3092de1dd0b02">FLOAT64</a>
<br />
 }</td></tr>
<tr class="memdesc:a382cd5d5a35ce21b5ae92ab9821c849c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of supported column data types.  <a href="namespacesplat.html#a382cd5d5a35ce21b5ae92ab9821c849c">More...</a><br /></td></tr>
<tr class="separator:a382cd5d5a35ce21b5ae92ab9821c849c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e7c2f7ae07b287f4c45ed56d387579"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesplat.html#a06e7c2f7ae07b287f4c45ed56d387579">logLevel</a> { <a class="el" href="namespacesplat.html#a06e7c2f7ae07b287f4c45ed56d387579a73be252ca82217b1458a25e6b4e99f15">silent</a>
, <a class="el" href="namespacesplat.html#a06e7c2f7ae07b287f4c45ed56d387579afea087517c26fadd409bd4b9dc642555">normal</a>
 }</td></tr>
<tr class="separator:a06e7c2f7ae07b287f4c45ed56d387579"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aca057d27b7f853b0e501bfffb6f7e971"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesplat.html#aca057d27b7f853b0e501bfffb6f7e971">writeCompressedPly</a> (const std::string &amp;filename, <a class="el" href="classsplat_1_1DataTable.html">DataTable</a> *dataTable)</td></tr>
<tr class="separator:aca057d27b7f853b0e501bfffb6f7e971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bfa1469594d0e1f3077bcf114fa2b11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesplat.html#a0bfa1469594d0e1f3077bcf114fa2b11">writeCSV</a> (const std::string &amp;path, <a class="el" href="classsplat_1_1DataTable.html">DataTable</a> *dataTable)</td></tr>
<tr class="separator:a0bfa1469594d0e1f3077bcf114fa2b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07152f181a31a582c288178ffc5f9546"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesplat.html#a07152f181a31a582c288178ffc5f9546">isCompressedPly</a> (const <a class="el" href="structsplat_1_1PlyData.html">PlyData</a> *ply)</td></tr>
<tr class="separator:a07152f181a31a582c288178ffc5f9546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa252f193c70195f18e271769fa16e2ad"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classsplat_1_1DataTable.html">DataTable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesplat.html#aa252f193c70195f18e271769fa16e2ad">decompressPly</a> (const <a class="el" href="structsplat_1_1PlyData.html">PlyData</a> *ply)</td></tr>
<tr class="separator:aa252f193c70195f18e271769fa16e2ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8111464ced8f5fc3d201a2a0c8f4ca5b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classsplat_1_1DataTable.html">DataTable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesplat.html#a8111464ced8f5fc3d201a2a0c8f4ca5b">readKsplat</a> (const std::string &amp;filename)</td></tr>
<tr class="separator:a8111464ced8f5fc3d201a2a0c8f4ca5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a863fe57c851c3c281943fb1f3973de82"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::unique_ptr&lt; <a class="el" href="classsplat_1_1DataTable.html">DataTable</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesplat.html#a863fe57c851c3c281943fb1f3973de82">readLcc</a> (const std::string &amp;filename, const std::string &amp;sourceName, const std::vector&lt; int &gt; &amp;options)</td></tr>
<tr class="separator:a863fe57c851c3c281943fb1f3973de82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77c9b8882c8228988d09532ac3a7e078"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesplat.html#a77c9b8882c8228988d09532ac3a7e078">writeLod</a> (const std::string &amp;filename, const <a class="el" href="classsplat_1_1DataTable.html">DataTable</a> *dataTable, <a class="el" href="classsplat_1_1DataTable.html">DataTable</a> *envDataTable, bool bundle, int iterations, size_t lodChunkCount, size_t lodChunkExtent)</td></tr>
<tr class="separator:a77c9b8882c8228988d09532ac3a7e078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c5aab9390912cf5d71af220b340f09b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classsplat_1_1DataTable.html">DataTable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesplat.html#a9c5aab9390912cf5d71af220b340f09b">readPly</a> (const std::string &amp;filename)</td></tr>
<tr class="memdesc:a9c5aab9390912cf5d71af220b340f09b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads and parses a PLY (Polygon File Format) file from disk.  <a href="namespacesplat.html#a9c5aab9390912cf5d71af220b340f09b">More...</a><br /></td></tr>
<tr class="separator:a9c5aab9390912cf5d71af220b340f09b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac139203466e1fd7c045852504ef676a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesplat.html#ac139203466e1fd7c045852504ef676a6">writePly</a> (const std::string &amp;filename, const <a class="el" href="structsplat_1_1PlyData.html">PlyData</a> &amp;plyData)</td></tr>
<tr class="separator:ac139203466e1fd7c045852504ef676a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36751c18195c40aa9ce84448e9c60c29"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classsplat_1_1DataTable.html">DataTable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesplat.html#a36751c18195c40aa9ce84448e9c60c29">readSog</a> (const std::string &amp;file, const std::string &amp;sourceName)</td></tr>
<tr class="memdesc:a36751c18195c40aa9ce84448e9c60c29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads and parses a Gaussian Splatting (.sog) file into a <a class="el" href="classsplat_1_1DataTable.html" title="Tabular data structure with typed columns.">DataTable</a>.  <a href="namespacesplat.html#a36751c18195c40aa9ce84448e9c60c29">More...</a><br /></td></tr>
<tr class="separator:a36751c18195c40aa9ce84448e9c60c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbfc654461a051b75a3356c5376e5e9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesplat.html#afbfc654461a051b75a3356c5376e5e9d">writeSog</a> (const std::string &amp;filename, <a class="el" href="classsplat_1_1DataTable.html">DataTable</a> *dataTable, bool bundle, int iterations, const std::vector&lt; uint32_t &gt; &amp;indices={})</td></tr>
<tr class="separator:afbfc654461a051b75a3356c5376e5e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b7809477624d084e15c34b97faeeda1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesplat.html#a9b7809477624d084e15c34b97faeeda1">writeSplat</a> (const <a class="el" href="classsplat_1_1DataTable.html">DataTable</a> *datatable, const std::string &amp;filepath)</td></tr>
<tr class="memdesc:a9b7809477624d084e15c34b97faeeda1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes 3D Gaussian splatting data to a .splat file format.  <a href="namespacesplat.html#a9b7809477624d084e15c34b97faeeda1">More...</a><br /></td></tr>
<tr class="separator:a9b7809477624d084e15c34b97faeeda1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c7242ade76de864daa0eb64b9d36848"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classsplat_1_1DataTable.html">DataTable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesplat.html#a7c7242ade76de864daa0eb64b9d36848">readSplat</a> (const std::string &amp;filename)</td></tr>
<tr class="memdesc:a7c7242ade76de864daa0eb64b9d36848"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads and parses a .splat file containing Gaussian splatting data.  <a href="namespacesplat.html#a7c7242ade76de864daa0eb64b9d36848">More...</a><br /></td></tr>
<tr class="separator:a7c7242ade76de864daa0eb64b9d36848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ce2054951931469676ca03b8dea87b3"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classsplat_1_1DataTable.html">DataTable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesplat.html#a5ce2054951931469676ca03b8dea87b3">readSpz</a> (const std::string &amp;filename)</td></tr>
<tr class="separator:a5ce2054951931469676ca03b8dea87b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6602a59955c1f74cc96dcb84bd4b3b5b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6602a59955c1f74cc96dcb84bd4b3b5b"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesplat.html#a6602a59955c1f74cc96dcb84bd4b3b5b">sigmoid</a> (T x)</td></tr>
<tr class="memdesc:a6602a59955c1f74cc96dcb84bd4b3b5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sigmoid activation function.  <a href="namespacesplat.html#a6602a59955c1f74cc96dcb84bd4b3b5b">More...</a><br /></td></tr>
<tr class="separator:a6602a59955c1f74cc96dcb84bd4b3b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5c99d995d33cde611bffa16444a8839"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesplat.html#af5c99d995d33cde611bffa16444a8839">simple_random</a> ()</td></tr>
<tr class="memdesc:af5c99d995d33cde611bffa16444a8839"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple deterministic pseudo-random number generator.  <a href="namespacesplat.html#af5c99d995d33cde611bffa16444a8839">More...</a><br /></td></tr>
<tr class="separator:af5c99d995d33cde611bffa16444a8839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a207d8f02958f0cda7b5886d6da5696ea"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classsplat_1_1DataTable.html">DataTable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesplat.html#a207d8f02958f0cda7b5886d6da5696ea">combine</a> (std::vector&lt; std::unique_ptr&lt; <a class="el" href="classsplat_1_1DataTable.html">DataTable</a> &gt;&gt; &amp;dataTables)</td></tr>
<tr class="memdesc:a207d8f02958f0cda7b5886d6da5696ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges multiple DataTables into a single combined table.  <a href="namespacesplat.html#a207d8f02958f0cda7b5886d6da5696ea">More...</a><br /></td></tr>
<tr class="separator:a207d8f02958f0cda7b5886d6da5696ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9370a258a80d896424204bb4bd445d87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesplat.html#a9370a258a80d896424204bb4bd445d87">sortMortonOrder</a> (const <a class="el" href="classsplat_1_1DataTable.html">DataTable</a> *dataTable, absl::Span&lt; uint32_t &gt; indices)</td></tr>
<tr class="memdesc:a9370a258a80d896424204bb4bd445d87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort Gaussian splats in Morton order (Z-order curve) for memory locality.  <a href="namespacesplat.html#a9370a258a80d896424204bb4bd445d87">More...</a><br /></td></tr>
<tr class="separator:a9370a258a80d896424204bb4bd445d87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a365a879a34fe2750bdf3dfc693a877e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesplat.html#a365a879a34fe2750bdf3dfc693a877e0">transform</a> (<a class="el" href="classsplat_1_1DataTable.html">DataTable</a> *dataTable, const Eigen::Vector3f &amp;t, const Eigen::Quaternionf &amp;r, float s)</td></tr>
<tr class="memdesc:a365a879a34fe2750bdf3dfc693a877e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply transformation to data table.  <a href="namespacesplat.html#a365a879a34fe2750bdf3dfc693a877e0">More...</a><br /></td></tr>
<tr class="separator:a365a879a34fe2750bdf3dfc693a877e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a535aec4b0840292ef644ac602f527793"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::unique_ptr&lt; <a class="el" href="classsplat_1_1DataTable.html">DataTable</a> &gt;, std::vector&lt; uint32_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesplat.html#a535aec4b0840292ef644ac602f527793">kmeans</a> (<a class="el" href="classsplat_1_1DataTable.html">DataTable</a> *points, size_t k, size_t iterations)</td></tr>
<tr class="separator:a535aec4b0840292ef644ac602f527793"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a034ac2e2d75dce80bc73c9188bff5e18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a034ac2e2d75dce80bc73c9188bff5e18">&#9670;&nbsp;</a></span>Row</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacesplat.html#a034ac2e2d75dce80bc73c9188bff5e18">splat::Row</a> = typedef std::map&lt;std::string, float&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents a single row of data as a map of column names to float values. </p>

</div>
</div>
<a id="a15efefd4b08a86eb5541d30becb14627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15efefd4b08a86eb5541d30becb14627">&#9670;&nbsp;</a></span>TypedArray</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacesplat.html#a15efefd4b08a86eb5541d30becb14627">splat::TypedArray</a> = typedef std::variant&lt;std::vector&lt;int8_t&gt;, std::vector&lt;uint8_t&gt;, std::vector&lt;int16_t&gt;, std::vector&lt;uint16_t&gt;, std::vector&lt;int32_t&gt;, std::vector&lt;uint32_t&gt;, std::vector&lt;float&gt;, std::vector&lt;double&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variant type representing different typed array storage options. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a382cd5d5a35ce21b5ae92ab9821c849c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a382cd5d5a35ce21b5ae92ab9821c849c">&#9670;&nbsp;</a></span>ColumnType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacesplat.html#a382cd5d5a35ce21b5ae92ab9821c849c">splat::ColumnType</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration of supported column data types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a382cd5d5a35ce21b5ae92ab9821c849caee9d73311ff0658494edfff14c3ec1e3"></a>INT8&#160;</td><td class="fielddoc"><p>Signed 8-bit integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="a382cd5d5a35ce21b5ae92ab9821c849caecfc091ed2a607335524c8389cfa41b5"></a>UINT8&#160;</td><td class="fielddoc"><p>Unsigned 8-bit integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="a382cd5d5a35ce21b5ae92ab9821c849ca5f90af42814c0a419d715d43ae54fd7a"></a>INT16&#160;</td><td class="fielddoc"><p>Signed 16-bit integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="a382cd5d5a35ce21b5ae92ab9821c849ca48d8f1a723d44ff4a87db1bb6c551c62"></a>UINT16&#160;</td><td class="fielddoc"><p>Unsigned 16-bit integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="a382cd5d5a35ce21b5ae92ab9821c849ca6495adba09844fac8eeb0aba86e6f1bf"></a>INT32&#160;</td><td class="fielddoc"><p>Signed 32-bit integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="a382cd5d5a35ce21b5ae92ab9821c849ca17266551181f69a1b4a3ad5c9e270afc"></a>UINT32&#160;</td><td class="fielddoc"><p>Unsigned 32-bit integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="a382cd5d5a35ce21b5ae92ab9821c849ca967d280b5c16d95f2947647dd2ca6cc2"></a>FLOAT32&#160;</td><td class="fielddoc"><p>32-bit floating point </p>
</td></tr>
<tr><td class="fieldname"><a id="a382cd5d5a35ce21b5ae92ab9821c849ca139882c654db8a57f7c3092de1dd0b02"></a>FLOAT64&#160;</td><td class="fielddoc"><p>64-bit floating point </p>
</td></tr>
</table>

</div>
</div>
<a id="a06e7c2f7ae07b287f4c45ed56d387579"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06e7c2f7ae07b287f4c45ed56d387579">&#9670;&nbsp;</a></span>logLevel</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacesplat.html#a06e7c2f7ae07b287f4c45ed56d387579">splat::logLevel</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a06e7c2f7ae07b287f4c45ed56d387579a73be252ca82217b1458a25e6b4e99f15"></a>silent&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a06e7c2f7ae07b287f4c45ed56d387579afea087517c26fadd409bd4b9dc642555"></a>normal&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a207d8f02958f0cda7b5886d6da5696ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a207d8f02958f0cda7b5886d6da5696ea">&#9670;&nbsp;</a></span>combine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classsplat_1_1DataTable.html">DataTable</a>&gt; splat::combine </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::unique_ptr&lt; <a class="el" href="classsplat_1_1DataTable.html">DataTable</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>dataTables</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges multiple DataTables into a single combined table. </p>
<p>Creates a union of columns (by name and type) and concatenates rows. Input tables are consumed (moved from) during the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataTables</td><td>Tables to combine (will be emptied) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Merged table, or nullptr if input is empty </dd></dl>

</div>
</div>
<a id="aa252f193c70195f18e271769fa16e2ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa252f193c70195f18e271769fa16e2ad">&#9670;&nbsp;</a></span>decompressPly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classsplat_1_1DataTable.html">DataTable</a>&gt; splat::decompressPly </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsplat_1_1PlyData.html">PlyData</a> *&#160;</td>
          <td class="paramname"><em>ply</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a07152f181a31a582c288178ffc5f9546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07152f181a31a582c288178ffc5f9546">&#9670;&nbsp;</a></span>isCompressedPly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool splat::isCompressedPly </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsplat_1_1PlyData.html">PlyData</a> *&#160;</td>
          <td class="paramname"><em>ply</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a535aec4b0840292ef644ac602f527793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a535aec4b0840292ef644ac602f527793">&#9670;&nbsp;</a></span>kmeans()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::unique_ptr&lt;<a class="el" href="classsplat_1_1DataTable.html">DataTable</a>&gt;, std::vector&lt;uint32_t&gt; &gt; splat::kmeans </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsplat_1_1DataTable.html">DataTable</a> *&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iterations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8111464ced8f5fc3d201a2a0c8f4ca5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8111464ced8f5fc3d201a2a0c8f4ca5b">&#9670;&nbsp;</a></span>readKsplat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classsplat_1_1DataTable.html">DataTable</a>&gt; splat::readKsplat </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a863fe57c851c3c281943fb1f3973de82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a863fe57c851c3c281943fb1f3973de82">&#9670;&nbsp;</a></span>readLcc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::unique_ptr&lt;<a class="el" href="classsplat_1_1DataTable.html">DataTable</a>&gt; &gt; splat::readLcc </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sourceName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9c5aab9390912cf5d71af220b340f09b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c5aab9390912cf5d71af220b340f09b">&#9670;&nbsp;</a></span>readPly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classsplat_1_1DataTable.html">DataTable</a>&gt; splat::readPly </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads and parses a PLY (Polygon File Format) file from disk. </p>
<p>This function loads a PLY file, parses its header and data sections, and returns a <a class="el" href="classsplat_1_1DataTable.html" title="Tabular data structure with typed columns.">DataTable</a> containing the vertex data. The function supports both ASCII and binary PLY formats and handles data in chunks for memory efficiency.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>Path to the PLY file to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::unique_ptr&lt;DataTable&gt; A smart pointer to a <a class="el" href="classsplat_1_1DataTable.html" title="Tabular data structure with typed columns.">DataTable</a> containing the vertex data from the PLY file. If the file contains compressed data, it will be decompressed automatically.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If:<ul>
<li>The file cannot be opened</li>
<li>The file header is invalid or missing the PLY magic bytes</li>
<li>The header exceeds the maximum size (128KB)</li>
<li>The 'end_header' marker is not found</li>
<li>Data chunks cannot be read properly</li>
<li>The file does not contain a vertex element</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The function reads data in chunks of 1024 rows at a time to optimize memory usage. Non-vertex elements are stored in the <a class="el" href="structsplat_1_1PlyData.html" title="Complete in-memory representation of PLY file data.">PlyData</a> structure but only vertex data is returned. If the PLY data is compressed, it will be decompressed before returning.</dd></dl>
<dl class="section user"><dt>File Format Support:</dt><dd><ul>
<li>Binary PLY format (little-endian)</li>
<li>Structured elements with properties</li>
<li>Optional compression (automatically detected and decompressed)</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd>parseHeader() For header parsing details </dd>
<dd>
<a class="el" href="namespacesplat.html#a07152f181a31a582c288178ffc5f9546">isCompressedPly()</a> For compression detection </dd>
<dd>
<a class="el" href="namespacesplat.html#aa252f193c70195f18e271769fa16e2ad">decompressPly()</a> For decompression logic </dd></dl>

</div>
</div>
<a id="a36751c18195c40aa9ce84448e9c60c29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36751c18195c40aa9ce84448e9c60c29">&#9670;&nbsp;</a></span>readSog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classsplat_1_1DataTable.html">DataTable</a>&gt; splat::readSog </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sourceName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads and parses a Gaussian Splatting (.sog) file into a <a class="el" href="classsplat_1_1DataTable.html" title="Tabular data structure with typed columns.">DataTable</a>. </p>
<p>This function loads and decodes a Gaussian Splatting scene stored in .sog format. The .sog format is a compressed representation of Gaussian splatting data that stores position, scale, color, rotation, and optionally higher-order spherical harmonics in an efficient texture-based encoding.</p>
<p>The function supports two input modes:</p><ol type="1">
<li>Reading from a single .sog ZIP archive file containing all components</li>
<li>Reading from individual component files in a directory structure</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>Path to the main .sog file or directory containing component files </td></tr>
    <tr><td class="paramname">sourceName</td><td>Source name/path used to locate component files. If sourceName ends with ".sog", the function treats it as a ZIP archive. Otherwise, it treats sourceName as a directory containing individual component files.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::unique_ptr&lt;DataTable&gt; containing the decoded Gaussian splatting data. The <a class="el" href="classsplat_1_1DataTable.html" title="Tabular data structure with typed columns.">DataTable</a> contains the following columns (at minimum):<ul>
<li>x, y, z: 3D positions (float)</li>
<li>scale_0, scale_1, scale_2: 3D scale factors (float)</li>
<li>f_dc_0, f_dc_1, f_dc_2: Spherical harmonic band 0 coefficients (RGB colors, float)</li>
<li>opacity: Opacity values (float)</li>
<li>rot_0, rot_1, rot_2, rot_3: Rotation quaternions (float) Additional columns for higher-order spherical harmonics (f_rest_*) are added if present in the source data.</li>
</ul>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if:<ul>
<li>The .sog file or component files cannot be opened/read</li>
<li>Required metadata (meta.json) is missing or invalid</li>
<li>Texture dimensions are insufficient for the declared splat count</li>
<li>File format inconsistencies are detected</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The function performs parallel processing using OpenMP for performance </dd>
<dd>
Position coordinates are transformed using invLogTransform to restore the original coordinate space </dd>
<dd>
Scale factors are decoded from a codebook-based quantization </dd>
<dd>
Rotation quaternions are unpacked from a compressed 8-bit per channel representation </dd>
<dd>
Colors and opacity are decoded from quantized SH0 coefficients with sigmoid inverse transformation for opacity </dd>
<dd>
Higher-order spherical harmonics (bands &gt; 0) are optionally decoded if present in the metadata</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structsplat_1_1Meta.html#a57e714c62a253e91c74bb5a24eee2265" title="Parse metadata from JSON byte array.">Meta::parseFromJson</a> </dd>
<dd>
decodeMeans </dd>
<dd>
unpackQuat </dd>
<dd>
invLogTransform </dd>
<dd>
sigmoidInv </dd></dl>

</div>
</div>
<a id="a7c7242ade76de864daa0eb64b9d36848"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c7242ade76de864daa0eb64b9d36848">&#9670;&nbsp;</a></span>readSplat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classsplat_1_1DataTable.html">DataTable</a>&gt; splat::readSplat </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads and parses a .splat file containing Gaussian splatting data. </p>
<p>This function loads a binary .splat file containing uncompressed Gaussian splatting data. Each splat is represented as a fixed 32-byte structure containing position, scale, color, opacity, and rotation data. The file format is a simple concatenation of these 32-byte records.</p>
<p>The .splat format stores data in the following layout per splat (all little-endian):</p><ul>
<li>Bytes 0-11: Position (x, y, z) as 3 × float32</li>
<li>Bytes 12-23: Scale (sx, sy, sz) as 3 × float32</li>
<li>Bytes 24-27: Color and opacity as 4 × uint8 (RGBA format)</li>
<li>Bytes 28-31: Rotation quaternion as 4 × uint8</li>
</ul>
<p>The function performs necessary conversions during loading:</p><ul>
<li>Position coordinates are used directly as float32 values</li>
<li>Scale factors are converted from linear to logarithmic space (logf)</li>
<li>Color values are converted from uint8 [0,255] range to spherical harmonic coefficients</li>
<li>Opacity values are converted from uint8 to float with inverse sigmoid transformation</li>
<li>Rotation quaternions are unpacked from uint8 representation and normalized</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Path to the .splat file to read</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::unique_ptr&lt;DataTable&gt; containing the parsed Gaussian splatting data. The <a class="el" href="classsplat_1_1DataTable.html" title="Tabular data structure with typed columns.">DataTable</a> contains exactly 14 columns in the following order:<ol type="1">
<li>x (float): X-coordinate position</li>
<li>y (float): Y-coordinate position</li>
<li>z (float): Z-coordinate position</li>
<li>scale_0 (float): Logarithm of first scale component (log scale)</li>
<li>scale_1 (float): Logarithm of second scale component (log scale)</li>
<li>scale_2 (float): Logarithm of third scale component (log scale)</li>
<li>f_dc_0 (float): Spherical harmonic DC term for red channel</li>
<li>f_dc_1 (float): Spherical harmonic DC term for green channel</li>
<li>f_dc_2 (float): Spherical harmonic DC term for blue channel</li>
<li>opacity (float): Opacity after inverse sigmoid transformation</li>
<li>rot_0 (float): First component of normalized rotation quaternion</li>
<li>rot_1 (float): Second component of normalized rotation quaternion</li>
<li>rot_2 (float): Third component of normalized rotation quaternion</li>
<li>rot_3 (float): Fourth component of normalized rotation quaternion</li>
</ol>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if:<ul>
<li>The file cannot be opened or does not exist</li>
<li>File size is not a multiple of 32 bytes (invalid format)</li>
<li>File is empty (0 bytes)</li>
<li>Failed to read expected amount of data during chunked reading</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The function reads data in chunks of 1024 splats (32KB) for memory efficiency </dd>
<dd>
Scale factors are stored as linear values in the file but converted to log scale internally for numerical stability in Gaussian computations </dd>
<dd>
Color conversion uses the spherical harmonic C0 constant (0.28209479177387814) to transform uint8 values to proper SH coefficients </dd>
<dd>
Invalid rotation quaternions (zero length) are replaced with identity quaternion [0,0,0,1] </dd>
<dd>
This format does not support higher-order spherical harmonics (SH bands &gt; 0)</dd></dl>
<dl class="section see"><dt>See also</dt><dd>BYTES_PER_SPLAT for the fixed record size </dd>
<dd>
readFloatLE for little-endian float reading </dd>
<dd>
readUInt8 for byte reading </dd></dl>

</div>
</div>
<a id="a5ce2054951931469676ca03b8dea87b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ce2054951931469676ca03b8dea87b3">&#9670;&nbsp;</a></span>readSpz()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classsplat_1_1DataTable.html">DataTable</a>&gt; splat::readSpz </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6602a59955c1f74cc96dcb84bd4b3b5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6602a59955c1f74cc96dcb84bd4b3b5b">&#9670;&nbsp;</a></span>sigmoid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T splat::sigmoid </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sigmoid activation function. </p>
<p>Computes the sigmoid (logistic) function: σ(x) = 1 / (1 + exp(-x)) This function maps real values to the range (0, 1) and is commonly used in machine learning for probabilities and activations.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Numeric type (float, double, etc.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Input value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sigmoid-transformed value in range (0, 1)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For Gaussian splatting, this is typically used to convert raw opacity values to valid opacity in [0, 1] range. </dd>
<dd>
Uses double-precision exponential for accuracy even with float input. </dd></dl>

</div>
</div>
<a id="af5c99d995d33cde611bffa16444a8839"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5c99d995d33cde611bffa16444a8839">&#9670;&nbsp;</a></span>simple_random()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float splat::simple_random </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simple deterministic pseudo-random number generator. </p>
<p>Generates a pseudo-random float in the range [0, 1) using a linear congruential generator (LCG). The generator is deterministic and thread-unsafe due to static internal state.</p>
<dl class="section return"><dt>Returns</dt><dd>Random float in range [0, 1)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a simple PRNG suitable for debugging, testing, or situations where reproducibility is more important than statistical quality. </dd>
<dd>
Not suitable for cryptographic or high-quality statistical applications. </dd>
<dd>
The generator uses the constants from POSIX rand() implementation: multiplier = 1103515245, increment = 12345, modulus = 2^31. </dd>
<dd>
Thread-unsafe: uses static internal state. </dd></dl>
<p>&lt; Initial seed (can be changed for different sequences)</p>

</div>
</div>
<a id="a9370a258a80d896424204bb4bd445d87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9370a258a80d896424204bb4bd445d87">&#9670;&nbsp;</a></span>sortMortonOrder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void splat::sortMortonOrder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsplat_1_1DataTable.html">DataTable</a> *&#160;</td>
          <td class="paramname"><em>dataTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; uint32_t &gt;&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort Gaussian splats in Morton order (Z-order curve) for memory locality. </p>
<p>This function computes a Morton ordering (Z-order curve) of the Gaussian splats based on their 3D positions to improve cache locality and memory access patterns. The Morton code interleaves the bits of the 3D coordinates to create a 1D ordering that preserves spatial proximity in multi-dimensional space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataTable</td><td>Pointer to the <a class="el" href="classsplat_1_1DataTable.html" title="Tabular data structure with typed columns.">DataTable</a> containing Gaussian splat data. Expected to have at least 'x', 'y', and 'z' columns representing the 3D positions of the splats. </td></tr>
    <tr><td class="paramname">indices</td><td>Output span that will be filled with the sorted indices in Morton order. Must be pre-allocated with size equal to the number of rows in dataTable. On output, indices[i] contains the original index of the i-th splat in Morton order.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The function assumes the position coordinates are normalized or bounded. </dd>
<dd>
Morton ordering is particularly effective for octree-based rendering and improves performance for spatially coherent operations. </dd>
<dd>
This is a key optimization for real-time Gaussian splatting rendering pipelines. </dd></dl>

</div>
</div>
<a id="a365a879a34fe2750bdf3dfc693a877e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a365a879a34fe2750bdf3dfc693a877e0">&#9670;&nbsp;</a></span>transform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void splat::transform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsplat_1_1DataTable.html">DataTable</a> *&#160;</td>
          <td class="paramname"><em>dataTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Quaternionf &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply transformation to data table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataTable</td><td>Table to transform </td></tr>
    <tr><td class="paramname">t</td><td>Translation vector </td></tr>
    <tr><td class="paramname">r</td><td>Rotation quaternion </td></tr>
    <tr><td class="paramname">s</td><td>Scale factor</td></tr>
  </table>
  </dd>
</dl>
<p>Applies translation, rotation, and scaling transformation to relevant columns in the data table. </p>

</div>
</div>
<a id="aca057d27b7f853b0e501bfffb6f7e971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca057d27b7f853b0e501bfffb6f7e971">&#9670;&nbsp;</a></span>writeCompressedPly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void splat::writeCompressedPly </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsplat_1_1DataTable.html">DataTable</a> *&#160;</td>
          <td class="paramname"><em>dataTable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0bfa1469594d0e1f3077bcf114fa2b11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bfa1469594d0e1f3077bcf114fa2b11">&#9670;&nbsp;</a></span>writeCSV()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void splat::writeCSV </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsplat_1_1DataTable.html">DataTable</a> *&#160;</td>
          <td class="paramname"><em>dataTable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a77c9b8882c8228988d09532ac3a7e078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77c9b8882c8228988d09532ac3a7e078">&#9670;&nbsp;</a></span>writeLod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void splat::writeLod </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsplat_1_1DataTable.html">DataTable</a> *&#160;</td>
          <td class="paramname"><em>dataTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsplat_1_1DataTable.html">DataTable</a> *&#160;</td>
          <td class="paramname"><em>envDataTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bundle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>lodChunkCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>lodChunkExtent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac139203466e1fd7c045852504ef676a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac139203466e1fd7c045852504ef676a6">&#9670;&nbsp;</a></span>writePly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void splat::writePly </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsplat_1_1PlyData.html">PlyData</a> &amp;&#160;</td>
          <td class="paramname"><em>plyData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afbfc654461a051b75a3356c5376e5e9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbfc654461a051b75a3356c5376e5e9d">&#9670;&nbsp;</a></span>writeSog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void splat::writeSog </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsplat_1_1DataTable.html">DataTable</a> *&#160;</td>
          <td class="paramname"><em>dataTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bundle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9b7809477624d084e15c34b97faeeda1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b7809477624d084e15c34b97faeeda1">&#9670;&nbsp;</a></span>writeSplat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void splat::writeSplat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsplat_1_1DataTable.html">DataTable</a> *&#160;</td>
          <td class="paramname"><em>datatable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filepath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes 3D Gaussian splatting data to a .splat file format. </p>
<p>This function converts internal Gaussian splatting data representation to the binary .splat file format, which is optimized for efficient storage and loading. The .splat format stores each Gaussian splat as a 32-byte record containing:</p><ul>
<li>Position (3 × float32): x, y, z coordinates</li>
<li>Scale (3 × float32): scale factors along each axis (stored as linear values)</li>
<li>Color and opacity (4 × uint8): RGB color and alpha opacity</li>
<li>Rotation (4 × uint8): Quaternion rotation encoded as normalized bytes</li>
</ul>
<p>The conversion process includes:</p><ul>
<li>Converting log-scale values to linear scale using exp()</li>
<li>Converting spherical harmonic coefficients to RGB color using SH_C0 constant</li>
<li>Applying sigmoid function to opacity values</li>
<li>Normalizing and encoding quaternion rotation to byte range [0, 255]</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">datatable</td><td>Pointer to the <a class="el" href="classsplat_1_1DataTable.html" title="Tabular data structure with typed columns.">DataTable</a> containing Gaussian splat data. Must contain the following columns:<ul>
<li>Position: "x", "y", "z" (float)</li>
<li>Scale: "scale_0", "scale_1", "scale_2" (float, log-scale)</li>
<li>Color: "f_dc_0", "f_dc_1", "f_dc_2" (float, spherical harmonics)</li>
<li>Opacity: "opacity" (float, log-space)</li>
<li>Rotation: "rot_0", "rot_1", "rot_2", "rot_3" (float, quaternion)</li>
</ul>
</td></tr>
    <tr><td class="paramname">filepath</td><td>Output file path where the .splat data will be written. The file will be created or overwritten if it exists.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the file cannot be opened for writing. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>If required columns are missing from the <a class="el" href="classsplat_1_1DataTable.html" title="Tabular data structure with typed columns.">DataTable</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The function writes data in binary format with little-endian byte order. Each splat is written as a 32-byte record, making the total file size predictable: num_splats × 32 bytes.</dd>
<dd>
For performance, the function flushes the output stream every 1000 splats to balance memory usage and I/O efficiency.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacesplat.html#a7c7242ade76de864daa0eb64b9d36848" title="Reads and parses a .splat file containing Gaussian splatting data.">readSplat()</a> for reading .<a class="el" href="namespacesplat.html">splat</a> files </dd>
<dd>
<a class="el" href="classsplat_1_1DataTable.html" title="Tabular data structure with typed columns.">DataTable</a> for data structure requirements </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
